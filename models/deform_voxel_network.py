import time

import torch
from torch import nn

from .sh_utils import eval_sh
from .voxel_networks import SVOXNGP, point_sample


def get_ckpt(ckpt_path):
    ckpt = torch.load(ckpt_path, map_location='cpu')
    return ckpt


def create_meshgrid3d(
        depth,
        height,
        width,
        normalized_coordinates=True,
        device=torch.device('cpu'),
        dtype=torch.float32,
) -> torch.Tensor:
    """Changing the order of meshgrid3d generated by kornia.

    Return:
        grid tensor with shape :math:`(1, D, W, H, 3)`.
    """
    xs = torch.linspace(0, width - 1, width, device=device, dtype=dtype)
    ys = torch.linspace(0, height - 1, height, device=device, dtype=dtype)
    zs = torch.linspace(0, depth - 1, depth, device=device, dtype=dtype)
    # Fix TracerWarning
    if normalized_coordinates:
        xs = (xs / (width - 1) - 0.5) * 2
        ys = (ys / (height - 1) - 0.5) * 2
        zs = (zs / (depth - 1) - 0.5) * 2
    # generate grid by stacking coordinates
    xs, ys, zs = torch.meshgrid([zs, xs, ys])
    base_grid = torch.stack([zs, ys, xs], dim=-1)  # DxWxHx3, (z, y, x)
    return base_grid.unsqueeze(0)


class DeformSVOXNGP(SVOXNGP):
    """NGP model with deformation field."""

    def __init__(
        self,
        ckpt_path,
        scale=0.5,
        init_reso=128,
        black_bg=False,
        ft_rgb=False,
        ret_xyz=False,
    ):
        super().__init__(scale, init_reso, black_bg)
        self.load_state_dict(get_ckpt(ckpt_path))

        self.ft_rgb = ft_rgb
        # fix params of ngp_model
        for kv in self.named_parameters():
            if self.ft_rgb and 'sh_grid' in kv[0]:
                continue
            kv[1].requires_grad = False

        # deformation field as 3D voxel grids
        self.deform_grid = nn.Parameter(
            torch.zeros((1, 3, init_reso, init_reso, init_reso),
                        dtype=torch.float32))
        self.deform_act = nn.Sigmoid()

        self.ret_xyz = ret_xyz  # to render flow

    def _post_proc_deform(self, offset):
        """Sigmoid and scale `offset`."""
        offset = self.deform_act(offset)  # sigmoid output, [0, 1]
        # since x is in [-1, 1], so offset should be in [-2, 2]
        return 4. * offset - 2.

    def deform(self, x):
        """
        Inputs:
            x: (N, 3), xyz in [-scale, scale]

        Outputs:
            x': (N, 3), xyz after deformation, in [-1, 1]
        """
        x = self._normalize_x(x)
        dx = point_sample(self.deform_grid, x)
        dx = self._post_proc_deform(dx)
        def_x = x + dx
        # def_x = torch.clamp(def_x, -1., 1.)
        return def_x

    def density(self, x):
        """
        Inputs:
            x: (N, 3) xyz after deformation

        Outputs:
            sigmas: (N)
        """
        x = self.deform(x)
        sigmas = self.svox2_grid.sample(x, want_colors=False)[0]
        sigmas = self.sigma_act(sigmas[:, 0])
        return sigmas

    def forward(self, x, d):
        """
        Inputs:
            x: (N, 3) xyz in [-scale, scale]
            d: (N, 3) directions

        Outputs:
            deform_x: (N, 3), x after deformation, denormalized to original scale
            sigmas: (N)
            rgbs: (N, 3)
        """
        x = self.deform(x)
        sigmas, shs = self.svox2_grid.sample(x)
        sigmas = self.sigma_act(sigmas[:, 0])
        rgbs = eval_sh(2, shs.unflatten(-1, (3, self.sh_basis_dim)), d)
        rgbs = self.rgb_act(rgbs)
        # return xyz
        if self.ret_xyz:
            return self._denormalize_x(x), sigmas, rgbs
        return sigmas, rgbs

    @torch.no_grad()
    def merge_deformation(self):
        """Apply deformation to grid data and zero deform."""
        print('\nMerge deformation to grid data.')
        print('Please re-init optimizer in the Trainer.')
        start_t = time.time()
        D, H, W = self.deform_grid.shape[-3:]
        dst_coords = create_meshgrid3d(
            D, H, W, normalized_coordinates=True).type_as(self.deform_grid)
        # `dst_coords` is [1, D, H, W, 3], in [-1, 1]
        # TODO: find those deformed coords, mask [1, D, H, W]
        # breakpoint()
        deform_mask = (
            self._post_proc_deform(self.deform_grid.data).abs().sum(1) > 1e-4)
        dst_coords = dst_coords[deform_mask].contiguous()  # [N, 3]
        deform_mask = deform_mask[0]  # [D, H, W]
        src_coords = dst_coords + self.deform_grid.data[
            0][:, deform_mask].transpose(0, 1).contiguous()
        # src_coords = dst_coords + self._post_proc_deform(
        #     self.deform_grid.data.permute(0, 2, 3, 4, 1).contiguous())
        # apply deformation
        self.svox2_grid.refine(src_coords, dst_coords, deform_mask)
        # re-init deformation field
        self.deform_grid.data.zero_()
        # time elapsed
        print(f'Merge deformation took {time.time() - start_t:.2f}s\n')

    def train(self, mode: bool = True):
        super().train(mode)
        # ngp_model should always in be in eval mode
        for kv in self.named_modules():
            if not kv[0]:  # model itself is ''
                continue
            if 'deform_grid' in kv[0]:
                continue
            if self.ft_rgb and 'sh_grid' in kv[0]:
                continue
            kv[1].eval()
        return self
